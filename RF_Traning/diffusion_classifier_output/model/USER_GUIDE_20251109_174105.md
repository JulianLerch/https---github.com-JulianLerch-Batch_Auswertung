# Random Forest Diffusion Classifier - Benutzerdokumentation

**Erstellt:** 2025-11-09 17:41:05

## 1. Model-Übersicht

Dieses Random Forest-Modell klassifiziert Single-Particle-Tracking Trajektorien in vier Diffusionsarten:

| Label | Diffusionstyp | Beschreibung |
|-------|---------------|--------------|
| 0 | Normal | Brownsche Bewegung (α = 1.0) |
| 1 | Subdiffusion | fraktale Brownsche Bewegung (α < 1, H < 0.5) |
| 2 | Confined | Räumlich begrenzte Diffusion |
| 3 | Superdiffusion | Persistente, gerichtete Bewegung (α > 1, H > 0.5) |

## 2. Performance-Metriken

### Finale Training-Ergebnisse:

- **OOB Score:** 0.9925
- **F1 Macro:** 1.0000

### F1-Scores pro Klasse:

- **Normal:** 1.0000
- **Subdiffusion:** 1.0000
- **Confined:** 1.0000
- **Superdiffusion:** 1.0000

## 3. Features

Das Modell verwendet folgende **18 Features** (in Wichtigkeitsreihenfolge):

| Feature | Importance | Beschreibung |
|---------|-----------|--------------|
| `convex_hull_area` | 0.1314 | Feature |
| `msd_ratio` | 0.0980 | MSD-Ratio R(4,1) - Plateaubildung bei Confinement |
| `hurst_exponent` | 0.0947 | Hurst-Exponent H = α/2 für fBm-Identifikation |
| `space_exploration_ratio` | 0.0928 | Feature |
| `fractal_dimension` | 0.0891 | Fraktale Dimension (≈2: raumfüllend) |
| `alpha` | 0.0886 | Anomaler Exponent aus MSD (α<1: sub, α=1: normal, α>1: super) |
| `efficiency` | 0.0881 | Nettoverschiebungs-Effizienz (→0: confined) |
| `mean_cos_theta` | 0.0646 | Mean Cosine Turning Angles (>0.5: persistent) |
| `vacf_lag1` | 0.0640 | Velocity Autocorrelation bei Lag 1 (wichtigstes Feature) |
| `vacf_min` | 0.0474 | Minimum der VACF (negative Werte bei Subdiffusion) |
| `persistence_length` | 0.0445 | Persistence Length (>>Schritt bei Superdiffusion) |
| `straightness` | 0.0418 | Straightness Index D/L (hoch bei Superdiffusion) |
| `msd_plateauness` | 0.0363 | Feature |
| `asphericity` | 0.0150 | Räumliche Asymmetrie (→1: linear, →0: isotrop) |
| `boundary_proximity_var` | 0.0027 | Feature |
| `confinement_probability` | 0.0005 | Feature |
| `kurtosis` | 0.0004 | Excess Kurtosis - Gaussianität (≈0: fBm, >0: CTRW) |
| `rg_saturation` | 0.0002 | Radius of Gyration Sättigung (Plateau: confined) |

## 4. Anwendung - Python Code

### 4.1 Modell laden

```python
import pickle
import numpy as np
import pandas as pd

# Modell und Scaler laden
with open('rf_diffusion_classifier_TIMESTAMP.pkl', 'rb') as f:
    model = pickle.load(f)

with open('feature_scaler_TIMESTAMP.pkl', 'rb') as f:
    scaler = pickle.load(f)
```

### 4.2 Feature-Extraktion aus eigener Trajektorie

```python
from diffusion_classifier_training import DiffusionFeatureExtractor

# Ihre Trajektorie: numpy array (N, 2) in μm
trajectory = np.array([...])  # Shape: (N_frames, 2)

# Integration time in Sekunden (Ihre Aufnahmefrequenz)
dt = 0.1  # 100ms

# Features extrahieren
extractor = DiffusionFeatureExtractor(trajectory, dt=dt)
features = extractor.extract_all_features()

# Zu DataFrame konvertieren (wichtig: richtige Reihenfolge!)
X = pd.DataFrame([features])
```

### 4.3 Klassifikation durchführen

```python
# Features skalieren
X_scaled = scaler.transform(X)

# Vorhersage
prediction = model.predict(X_scaled)[0]
probabilities = model.predict_proba(X_scaled)[0]

# Label-Mapping
label_map = {
    0: 'Normal Diffusion',
    1: 'Subdiffusion (fBm)',
    2: 'Confined Diffusion',
    3: 'Superdiffusion'
}

print(f"Predicted Class: {label_map[prediction]}")
print(f"Confidence: {probabilities[prediction]:.2%}")
print("\nAll Probabilities:")
for i, prob in enumerate(probabilities):
    print(f"  {label_map[i]}: {prob:.2%}")
```

### 4.4 Batch-Klassifikation mehrerer Trajektorien

```python
trajectories_list = [traj1, traj2, traj3, ...]  # Liste von Trajektorien

# Features für alle Trajektorien extrahieren
feature_list = []
for traj in trajectories_list:
    extractor = DiffusionFeatureExtractor(traj, dt=0.1)
    features = extractor.extract_all_features()
    feature_list.append(features)

X_all = pd.DataFrame(feature_list)

# Klassifikation
X_scaled = scaler.transform(X_all)
predictions = model.predict(X_scaled)
probabilities = model.predict_proba(X_scaled)

# Ergebnisse
results_df = pd.DataFrame({
    'trajectory_id': range(len(trajectories_list)),
    'predicted_class': [label_map[p] for p in predictions],
    'confidence': [probs[pred] for pred, probs in zip(predictions, probabilities)]
})
```

## 5. Wichtige Hinweise

### 5.1 Eingabedaten-Anforderungen

- **Format:** numpy array mit Shape (N, 2) für 2D-Trajektorien
- **Einheiten:** Positionen in **Mikrometern (μm)**
- **Minimale Länge:** ≥50 Frames für zuverlässige Feature-Extraktion
- **Integration Time:** Muss mit dt-Parameter übereinstimmen (typisch 0.1s)

### 5.2 Feature-Reihenfolge

**KRITISCH:** Features müssen in exakter Reihenfolge vorliegen wie beim Training.
Die `DiffusionFeatureExtractor`-Klasse garantiert dies automatisch.

Manuelle Feature-Extraktion ist **nicht empfohlen** - nutzen Sie die bereitgestellte Klasse!

### 5.3 Skalierung

Features **müssen** mit dem gespeicherten Scaler transformiert werden vor Klassifikation.
Ohne Skalierung sind die Vorhersagen **ungültig**.

### 5.4 Konfidenz-Interpretation

- **>90%:** Hochsichere Klassifikation
- **70-90%:** Gute Klassifikation
- **50-70%:** Moderate Unsicherheit, manuell prüfen
- **<50%:** Unsicher, weitere Analyse empfohlen

Bei niedriger Konfidenz: Prüfen Sie Feature-Werte manuell auf Plausibilität.

## 6. Troubleshooting

### Problem: Unrealistische Vorhersagen

**Ursachen:**
1. Falsche Einheiten (nicht μm)
2. Falscher dt-Wert
3. Lokalisierungsrauschen nicht korrigiert
4. Zu kurze Trajektorie (<50 Frames)

**Lösung:** Prüfen Sie Ihre Eingabedaten und Parameter.

### Problem: NaN in Features

**Ursache:** Trajektorie zu kurz oder degeneriert.

**Lösung:** Features werden automatisch mit Median gefüllt, aber Qualität sinkt.
Verwenden Sie längere Trajektorien.

### Problem: Niedriger Confidence Score

**Interpretation:** Trajektorie zeigt gemischte Charakteristiken.
Dies kann biologisch relevant sein (Zustandsübergänge).

**Analyse:** Schauen Sie sich die Probability-Verteilung an - gibt es eine zweite
plausible Klasse? Führen Sie Segment-Analyse durch.

## 7. Wissenschaftliche Referenzen

Dieses Modell basiert auf:

1. **Muñoz-Gil et al.** (2021) *Nature Communications* - AnDi Challenge
2. **Loch-Olszewska & Szwabiński** (2020) *Entropy* - Feature Engineering
3. **Wagner et al.** (2017) *Biophysical Journal* - Spatial Features
4. **Kepten et al.** (2015) *PLOS ONE* - MSD Analysis Guidelines

## 8. Support und Weiterentwicklung

Bei Fragen oder Problemen:
- Prüfen Sie diese Dokumentation
- Validieren Sie Ihre Eingabedaten
- Testen Sie mit synthetischen Trajektorien (siehe training code)

---

**Viel Erfolg bei der Diffusionsanalyse!**
